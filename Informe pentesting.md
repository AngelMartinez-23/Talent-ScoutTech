
# **Parte 1 - SQLi**

## **a) Identificación de un error por inyección SQL en el login**

Durante las pruebas realizadas en el formulario de inicio de sesión, se detectó que el campo de entrada destinado al nombre de usuario permite realizar inyecciones SQL. Esto quedó en evidencia al introducir caracteres especiales, como comillas dobles (`"`) en el campo, lo que provocó que la aplicación devolviera un mensaje de error exponiendo la consulta SQL.

**Ejemplo del error generado:**  
![Imagen 1](/imagen/Imagen1.png)

El error reveló que los datos introducidos por el usuario se integran directamente en la consulta SQL sin validarse ni escapar correctamente, lo que permite a un atacante manipular la consulta para acceder a información sensible.

**Consulta expuesta en el mensaje de error:**  
![Imagen 2](/imagen/Imagen2.png)

<br>

## **b) Explotación de la vulnerabilidad SQL para suplantar usuarios**

Se aprovechó la vulnerabilidad detectada para realizar un ataque de suplantación de usuario. Utilizando el campo de usuario susceptible a inyección SQL, se intentaron diversas combinaciones de contraseñas manualmente. Dado que solo había seis contraseñas posibles, se probó cada una de ellas directamente en el formulario de inicio de sesión, manipulando el campo de usuario para inyectar una consulta SQL que permitiera omitir la validación de la contraseña.

**Payload utilizado en la inyección SQL:**  

![Imagen 3](/imagen/Imagen3.png)

Con las credenciales obtenidas, se verificó que el usuario podía iniciar sesión correctamente:

![Imagen 4](/imagen/imagen4.png)

Tras iniciar sesión con las credenciales obtenidas a través de la inyección SQL, se accedió a la sección de comentarios de la aplicación. Al agregar un comentario relacionado con uno de los jugadores, y posteriormente visualizarlo.

**Imagen mostrando el proceso de agregar un comentario:**

![Imagen 5](/imagen/Imagen5.png)

En la imagen anterior, se puede ver cómo se agrega un comentario. Al mostrar el comentario agregado, se revela el nombre de usuario de la persona que lo introdujo, confirmando que el sistema permite ver dicha información.

**Imagen que muestra el nombre de usuario reflejado junto al comentario:**

![Imagen 6](/imagen/Imagen6.png)
<br>

## **c) Propuesta de solución para evitar la inyección SQL**

Al analizar el archivo `auth.php`, se identificó que la función `areUserAndPasswordValid()` realiza la validación de las credenciales, pero utiliza `SQLite3::escapeString()` para sanitizar la entrada de los usuarios. Aunque esta función ayuda a gestionar algunos caracteres especiales, no es suficiente para proteger completamente la consulta contra inyecciones SQL. Al depender de este método, la aplicación sigue siendo vulnerable a manipulaciones que permiten a un atacante modificar la consulta SQL y acceder a datos sensibles.

**Fragmento de código vulnerable:**

```php
$sql = "SELECT userId FROM users WHERE username = '" . $username . "' AND password = '" . $password . "'";
```

Para mitigar esta vulnerabilidad y asegurar la protección de los datos, se recomienda el uso de **consultas preparadas** con **parámetros vinculados**. Las consultas preparadas son una forma más segura de ejecutar consultas SQL, ya que separan las instrucciones SQL de los datos proporcionados por el usuario. Esto significa que los datos del usuario nunca se interpretan como parte de la consulta SQL, evitando que un atacante pueda inyectar código malicioso.

**Código corregido utilizando consultas preparadas:**

```php
$query = $db->prepare('SELECT userId, password FROM users WHERE username = :username');
$query->bindValue(':username', $user, SQLITE3_TEXT);
$result = $query->execute();
```

De esta forma, en lugar de introducir directamente el valor de la variable en la consulta, el valor se vincula a un parámetro en la consulta utilizando el formato adecuado para la base de datos, lo que garantiza que se trate como un valor literal y no como parte del código SQL, evitando así posibles inyecciones.

<br>

## **d) Ataque comentarios**

La vulnerabilidad detectada en la aplicación radica en el hecho de que al insertar un comentario, la aplicación depende de la cookie que guarda el identificador del usuario (`userId`). Esta cookie se utiliza para asociar el comentario con el usuario correspondiente, pero al no estar protegida adecuadamente, un atacante podría modificarla.

**Fragmento de código vulnerable relacionado con el uso de la cookie `userId`:**

```php
$userId = $_COOKIE['userId']; // Se obtiene el userId de la cookie
$sql = "INSERT INTO comments (userId, comment) VALUES ('$userId', '$comment')";
```

Se intentó crear y modificar manualmente la cookie `userId` con el fin de suplantar a otro usuario, pero a pesar de este intento, no se logró modificar el usuario de los comentarios.

Al cambiar el valor de la cookie `userId`, los comentarios continuaron realizándose desde el mismo usuario, lo que sugiere que la aplicación no valida correctamente el `userId` al momento de registrar los comentarios, permitiendo que los cambios en la cookie no afecten el comportamiento esperado.

**Resultado de la prueba:**  
A pesar de haber cambiado el valor de la cookie, ambos comentarios se siguieron asociando al mismo usuario.
 
![Imagen 7](/imagen/Imagen7.png)

<br>
<br>

# **Parte 2 - XSS**

## **a) Prueba de vulnerabilidad XSS con script en comentarios**

Se llevó a cabo una prueba para determinar si la aplicación es susceptible a ataques de Cross-Site Scripting (XSS). Para ello, se accedió a la sección de comentarios del jugador con ID 5, ubicada en la URL [http://localhost:8080/add_comment.php?id=5](http://localhost:8080/add_comment.php?id=5). En esta página, es posible dejar un comentario asociado a dicho jugador. 

![Imagen 8](/imagen/Imagen8.png)

Para probar la vulnerabilidad, se introdujo un comentario que contenía un fragmento de código JavaScript diseñado para ejecutar una alerta al ser mostrado.

**Resultado de la prueba de inyección de XSS:**

![Imagen 9](/imagen/Imagen9.png)

<br>

## **b) Uso del carácter &amp;**

El símbolo "\&amp;" se utiliza en HTML para representar el carácter "&". Si un usuario introduce solo el símbolo "&", este podría ser procesado y limpiado como un carácter especial. Sin embargo, si el usuario emplea "\&amp;", este se muestra correctamente como el símbolo "&" en la aplicación, ya que se interpreta como una entidad HTML válida.

<br>

## **c) Vulnerabilidad en show_comments.php y corrección**

El código en el archivo "show_comments.php" presenta una vulnerabilidad relacionada con el manejo de los comentarios. No se escapan adecuadamente los datos introducidos por los usuarios antes de mostrarlos como HTML, lo que podría permitir la ejecución de código JavaScript malicioso (XSS).

**Solución propuesta:**

Para corregir este problema, es necesario modificar el código para utilizar la función `htmlspecialchars()`, la cual convierte los caracteres especiales en sus correspondientes entidades HTML, evitando que se interpreten como parte del código HTML.

**Código original vulnerable:**

```php
echo "<div><h4>" . $row['username'] . "</h4><p>commented: " . $row['body'] . "</p></div>";
```

**Código corregido**

```php
echo "<div><h4>" . htmlspecialchars($row['username'], ENT_QUOTES, 'UTF-8') . "</h4><p>commented: " . htmlspecialchars($row['body'], ENT_QUOTES, 'UTF-8') . "</p></div>";
```

<br>

## **d) Identificación de otras páginas afectadas por XSS y análisis**

Además de la página "show_comments.php", otras páginas también se encuentran afectadas por la vulnerabilidad XSS debido a que no se escapan adecuadamente las entradas de los usuarios. Al insertar comentarios o interactuar con estas páginas, es posible inyectar código JavaScript, lo que permite la ejecución de scripts maliciosos cuando se visualizan las páginas afectadas.

**Páginas afectadas:**
- `add_comment.php`
- `show_comments.php`

**Análisis:**

Al revisar el código de estas páginas, se observó que no se validan ni escapan correctamente los datos introducidos por los usuarios, lo que genera un entorno vulnerable a ataques de tipo XSS. Esto significa que al insertar un comentario en cualquiera de los formularios, los scripts pueden ejecutarse al mostrar los comentarios en la página de listado, comprometiendo la seguridad de los usuarios.

Para mitigar esta vulnerabilidad, es crucial implementar técnicas de escape, como `htmlspecialchars()`, en todas las páginas que muestran datos proporcionados por el usuario.

# **Parte 3 - Control de acceso, autenticación y sesiones de usuarios**

## **a) Implementación de sesiones en “register.php"**

El primer paso es implementar sesiones para garantizar que cada usuario tenga una sesión única durante su interacción con la aplicación. Es necesario iniciar la sesión en todas las páginas donde se requiera acceso de usuario. En el archivo “register.php”, se debe iniciar la sesión y asignar el nombre de usuario y la contraseña a la sesión de la siguiente forma:

```php
session_start();
$_SESSION['username'] = $username;
$_SESSION['password'] = $password;
```
<br>

## **b) Implementación de “login.php”**

De manera similar a lo que se hizo en “register.php”, en “login.php” se debe iniciar la sesión y asignar los valores de nombre de usuario y contraseña a la sesión una vez validada la información contra la base de datos. El proceso de validación incluye comparar la contraseña ingresada con la versión hasheada almacenada en la base de datos. El código para este proceso sería algo como esto:

```php
session_start();
if (password_verify($password, $storedHashedPassword)) {
    $_SESSION['username'] = $username;
    $_SESSION['password'] = $password;
}
```

## **c) Restringir el acceso al archivo “register.php”**

Para proteger el archivo “register.php” de accesos no autorizados, es recomendable moverlo a una carpeta privada en el servidor. Esto evitará que cualquier usuario pueda acceder directamente al archivo si conoce su ruta. La carpeta podría llamarse “private” para mayor seguridad.

Además, se debe crear un archivo `.htaccess` dentro de la carpeta para restringir el acceso. El archivo `.htaccess` podría incluir las siguientes reglas:

```apache
<Files "register.php">
    Require all denied
</Files>
```

## **d) Configuración de accesibilidad para la carpeta “private”**

Para asegurar que solo los usuarios autorizados puedan acceder a la carpeta privada, es necesario configurar restricciones de acceso desde el servidor web. Esto se logra mediante el archivo `.htaccess` en un servidor Apache. Si este archivo no existe, debe ser creado y configurado adecuadamente. La configuración incluye la adición de la ruta del archivo que contendrá el usuario y la contraseña de acceso, el cual puede ser generado ejecutando el siguiente comando en el servidor:

```bash
htpasswd -c /ruta/a/archivo/.htpasswd username
```

# **Parte 4 - Medidas de Seguridad en Servidores Web**

Para reducir los riesgos en el servidor web, se recomienda implementar las siguientes medidas:

1. **Mantener el software actualizado**: Actualizar el sistema operativo y aplicaciones regularmente.
2. **Configurar el servidor adecuadamente**: Cerrar puertos innecesarios y desactivar cuentas predeterminadas.
3. **Usar autenticación segura**: Implementar autenticación multifactor.
4. **Configurar un firewall**: Filtrar tráfico no autorizado.
5. **Cifrar conexiones remotas**: Usar SSH o HTTPS en lugar de HTTP.
6. **Monitorear la actividad de los usuarios**: Detectar accesos o comportamientos sospechosos.
7. **Realizar copias de seguridad**: Guardar datos y configuraciones de manera periódica.
8. **Cifrar datos sensibles**: Proteger la información almacenada mediante cifrado.
9. **Fortalecer la seguridad de la base de datos**: Limitar accesos y aplicar cifrado.

# **Parte 5 - CSRF**

## **a) Edición de Jugador**

Para agregar un botón debajo del nombre del equipo al editar un jugador, es necesario insertar el código adecuado para mostrar un botón "Profile". Este botón debe redirigir al enlace correspondiente, tal como se muestra en el siguiente ejemplo.

![Imagen 10](/imagen/Imagen10.png)

![Imagen 11](/imagen/Imagen11.png)

![Imagen 12](/imagen/Imagen12.png)

Con este código, el botón "Profile" llevará directamente al enlace que gestiona la transferencia del jugador.

<br>

## **b) Enlace en Comentarios**

Para que el código de los comentarios incluya un enlace adecuado, se debe utilizar la función `fetch()` para acceder a los datos y mostrar el enlace correctamente en la interfaz de usuario. Aquí tienes un ejemplo de cómo implementarlo:

![Imagen 13](/imagen/Imagen13.png)

## **c) Verificación del enlace**

Para asegurarse de que el enlace se ejecute correctamente, se debe verificar que la cookie que contiene el ID de sesión no esté vacía. Si la cookie tiene un valor, esto indica que el usuario ha iniciado sesión y el enlace se podrá utilizar.

## **d) Página "donate.php"**

Para mejorar la seguridad, se recomienda cambiar el método de envío de datos de **GET** a **POST** en la página "donate.php". Esto evitará que los parámetros sean visibles en la URL. 

Se puede utilizar **Insomnia** para realizar peticiones POST con los parámetros necesarios de forma segura.
